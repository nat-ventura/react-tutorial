import React from "react";
import ReactDOM from "react-dom";

import Footer from "./Footer";
// idk why but these should be alphabetized..
import Header from "./components/Header";

// we capitalize as a standard because they're constructors
// the header isn't a rendered dom element yet,
// BUT HAS THE CAPACITY TO BE RENDERED
// if you want to render multiple version of something....
// you can make an array of three dom elements
// ie...
// var list = [
//     <Header />,
//     <Header />,
//     <Header />,
// ];
// return (
//     <div>
//         {list}
//     </div>
// )
// you'd do this if your main was an unordered list or something
// and each thing was an li-- which its own specific info passed in

const app = document.getElementById('app');
ReactDOM.render(<Layout/>, app);

export default class Layout extends React.Component {
    constructor() {
        super();
        this.state = {title: 'welcome'}
        // WHENEVER STATE CHANGES ON A COMPONENT
        // THE COMPONENT WILL AUTOMATICALLY RE-RENDER
        // AND UPDATE THE DOM IF THERE ARE ANY CHANGES
        // --- IF NO CHANGES, THE DOM WON'T BE TOUCHED AT ALL
        //
        // REACT MANAGES A VIRTUAL DOM FOR YOU
        // WHENEVER REACT RENDERS OUT ALL THE COMPONENTS
        // -- the component tree (the layout, header, footer, etc)
        // then looks for changes from virtual DOM to ACTUAL DOM
        // if there are changes,
        // then it will UPDATE ONLY THE AFFECTED NODES IN THE MOST EFFICIENT WAY
        // if no changes,
        // it doesn't even touch the webpage.

        // js is fast, but DOM is soooo slow
        // a virtual DOM allows apps to be super fast

        // we can change the state with a set timeout
    }
    render() {
        const title = "welcome nat";
        setTimeout(() => {
            this.setState({title: "welcome nat"})
        }, 2000)
        // after two seconds, our header component will be updated
        // TWO SECONDS IN, ONLY THE H1 CHANGED
        // BC EVEN THO HEADER COMPONENT RECEIVED AN UPDATE, NEW PROP
        // RENDERED OUT THE EXACT SAME DIV
        // NO CHANGES
        // CHILD COMPONENT OF TITLE CHANGED
        // SO IT UPDATED THE H1 AND THE H1 ONLY
        // NO MATTER HOW MANY COMPONENTS CHANGE
        // ONLY THE DOM IS UPDATED WITH THE ACTUAL ELEMENT CHANGES
        // THAT GOT CREATED WHEN THE ENTIRE TREE RENDERED

        return (
            <div>
        {/* //         {this.state.name} */}
                <Header title={this.state.title} />
                {/*this is called ^ injecting a prop  */}
                <Header title={"Other Title"} />
                {/*passes in a different title to each header  */}
                <Footer />
                {/*it's capitalized and components can render anywhere in the html*/}
            </div>
        );
    }
}

// data is handled through STATE and PROPS

// STATE
// you'll use PROPS a lot more though

// he showed that even when we do a complete new render of
// header, footer, entire layout-- the only dom element that changed
// was the one that contained the state.name

// react automatically manages dom manipulation for us
// vs in backbone--
// always question of when to update the dom
// and when i do, who should update the dom?
// should the list component re-render the whole list?
// or should just each list item manage rendering itself?

// react is like NO
// we're going to render EVERYTHING ALL THE TIME
// but only in js
// and only touch dom if something is changed
// that would reflect in a VISUAL WAY
// that's how you manage state

// STATE MENTALITY:
// only used if component has an internal value
// that only affects that component and none of the rest of the app
// if something effects layout but nothing else-- state may be appropriate
// aside from that
// use props-- INJECTED TO EVERY OTHER COMPONENT